package com.tencent.msdk;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Properties;
import java.util.Set;

import android.app.Activity;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.net.Uri;
import android.os.Bundle;
import android.widget.Toast;

import com.tencent.beacon.event.UserAction;
import com.tencent.connect.share.QQShare;
import com.tencent.mm.sdk.modelbiz.AddCardToWXCardPackage;
import com.tencent.mm.sdk.modelmsg.SendAuth;
import com.tencent.mm.sdk.modelmsg.SendMessageToWX;
import com.tencent.mm.sdk.modelmsg.WXAppExtendObject;
import com.tencent.mm.sdk.modelmsg.WXImageObject;
import com.tencent.mm.sdk.modelmsg.WXMediaMessage;
import com.tencent.mm.sdk.modelmsg.WXMusicObject;
import com.tencent.mm.sdk.modelmsg.WXWebpageObject;
import com.tencent.mm.sdk.openapi.IWXAPI;
import com.tencent.mm.sdk.openapi.WXAPIFactory;
import com.tencent.msdk.ad.ADManager;
import com.tencent.msdk.ad.ADPosInfo;
import com.tencent.msdk.api.CardRet;
import com.tencent.msdk.api.GroupRet;
import com.tencent.msdk.api.LoginRet;
import com.tencent.msdk.api.MsdkBaseInfo;
import com.tencent.msdk.api.ShareRet;
import com.tencent.msdk.api.TokenRet;
import com.tencent.msdk.api.WGADObserver;
import com.tencent.msdk.api.WGGroupObserver;
import com.tencent.msdk.api.WGPlatformObserver;
import com.tencent.msdk.api.WGQZonePermissions;
import com.tencent.msdk.api.eQQScene;
import com.tencent.msdk.api.eWechatScene;
import com.tencent.msdk.config.ConfigManager;
import com.tencent.msdk.consts.CallbackFlag;
import com.tencent.msdk.consts.Consts;
import com.tencent.msdk.consts.EPlatform;
import com.tencent.msdk.consts.ErrorCodeFlag;
import com.tencent.msdk.control.SwitcherManager;
import com.tencent.msdk.doctor.MsdkDoctor;
import com.tencent.msdk.handle.MsdkThreadManager;
import com.tencent.msdk.locallog.SaveLogHelper;
import com.tencent.msdk.login.LoginInfoManager;
import com.tencent.msdk.login.LoginManager;
import com.tencent.msdk.login.LoginTimer;
import com.tencent.msdk.login.LoginUtils;
import com.tencent.msdk.myapp.autoupdate.AutoUpdateManager;
import com.tencent.msdk.myapp.whitelist.WhiteListMng;
import com.tencent.msdk.notice.NoticeManager;
import com.tencent.msdk.pf.WGPfManager;
import com.tencent.msdk.push.PushSwitchMng;
import com.tencent.msdk.qq.ApiName;
import com.tencent.msdk.qq.QQLogin;
import com.tencent.msdk.qq.QQVersionApiManager;
import com.tencent.msdk.stat.MsdkStat;
import com.tencent.msdk.stat.ReportEvent;
import com.tencent.msdk.stat.Stat;
import com.tencent.msdk.stat.eEVENT_TYPE;
import com.tencent.msdk.stat.crash.CrashReportApi;
import com.tencent.msdk.stat.crash.GameStatus;
import com.tencent.msdk.timer.TaskManager;
import com.tencent.msdk.timer.TaskNameConst;
import com.tencent.msdk.timer.task.ADTask;
import com.tencent.msdk.timer.task.NoticeTask;
import com.tencent.msdk.tools.Logger;
import com.tencent.msdk.tools.SharedPreferencesTool;
import com.tencent.msdk.tools.T;
import com.tencent.msdk.tools.VersionHelper;
import com.tencent.msdk.webview.WebViewManager;
import com.tencent.open.GameAppOperation;
import com.tencent.stat.common.StatConstants;
import com.tencent.tauth.IUiListener;
import com.tencent.tauth.Tencent;
import com.tencent.tauth.UiError;

/**
 * 提交完这次代码就让hardyshi清理代码权限了, 那一刻也就算我正式退出MSDK了, 一年多时间, 还是有些不舍(求别说幼稚), 
 * 
 * 对msdk的感情比较特殊吧, 它在关键时候帮了我(暂且这么理解吧), 我也和MSDK"挺"过了那段最难的时候, 每次说到这都会想到大族4楼深夜那个唯一亮着灯的座位.
 * 
 * 唉, 写了很多又删了, 觉得太矫情, 主要是不知道哪些东西应该留在这个svn代码库里面. 
 * 
 * 最后, 祝福所有兄弟们越来越好, 希望大家以后都能开心健康的工作/生活. 再见, MSDK...!!!  
 * 
 * PS: 如果以后用新版本了, 求把这段注释保留在这个老版本里面, 让他长眠于此. 谢谢
 *     另, 如果你注意到了这段注释, 求别宣扬, 让他安静的躺在这里就好了, 再谢
 * @author erichua
 *
 */
public final class WeGame {
	//票据类型, QQHALL不算做票据类型, 平台ID标识统一使用平台传入的platformId字段标识
	public final static int WXPLATID = EPlatform.ePlatform_Weixin.val();
	public final static int QQPLATID = EPlatform.ePlatform_QQ.val();
	public static final int QQHALL = EPlatform.ePlatform_QQHall.val();
	// TODO MSDK_NEVER_DELETE 确认MSDK版本号是否变更
	private static final String MSDK_VERSION = "2.11.0a";

	// 回调的Flag默认设置为成功
	private int flag = CallbackFlag.eFlag_Succ;
	private Activity mActivity = null;

	private Activity firstGameActivity = null;
	private int mPlatId = 0;
	public String qq_appid = "";
	public String wx_appid = "";
	private String qqAppKey = "";
	private String msdkKey = "";
	
	private Tencent mTencent;
	public IWXAPI api;
	public String mPermission = "all";
	private Stat mStat = new Stat();
	private volatile static WeGame instance;
	public String offerId = null;
	// 添加版本号的控制
    public String appVersionName = "";
    // 添加版本versionCode的控制
    public int appVersionCode = -1;
	
	// Msdk 线程管理
	private MsdkThreadManager threadMgn;
	// 微信缩略图支持32k, 这里200为最长边的像素值
	private final int THUMB_SIZE = 200; 
	// 微信分享图片的限制值
	// 32k
	private final int THUMB_MAX_SIZE = 32000;
	// 10M
	private final int IMG_MAX_SIZE = 10 * 1000 * 1000;
	// 3M
	private final long IMG_LIMIT_SIZE = 3 * 1024 * 1024;
    private boolean mFirstStart = true;
    public void setFirstStartFlag(boolean flag){
        mFirstStart = flag;
    }
    
    public boolean getFirstStartFlag(){
        return mFirstStart;
    }
    
	// 记录微信首次登录时间
	private long wxRequestStartTime = 0;
	public long getWxRequestStartTime(){
	    return wxRequestStartTime;
	}
	
	// 抢号SDK Manager
	public static WeGame getInstance() {
		if (instance == null) {
			synchronized (WeGame.class) {
				if (instance == null) {
					instance = new WeGame();
				}
			}
		}
		return instance;
	}
	
	public boolean IsDifferentActivity(Activity activity) {
		if (null != this.firstGameActivity
				&& !this.firstGameActivity.equals(activity)) {
			return true;
		}
		return false;
	}
    
    public void onDestory(Activity game) {
        unRegisterADReportReceiver();
		// 如果挡墙结束的Activity是保存在WeGame中的，则清空
		if (game != null && game.equals(firstGameActivity)) {
			this.firstGameActivity = null;
		}
	}

	/**
	 * 初始化接口
	 * 
	 * @param wx_appId
	 *            微信appid
	 * @param qq_appId
	 *            QQ appid
	 * **/
	public void Initialized(Activity activity, MsdkBaseInfo baseInfo) {
		//设置日志记录方法
		Logger.setLogType(activity);
		Logger.d("Initialized start: " + this.wx_appid + "-" + this.qq_appid);
		this.mActivity = activity;
		this.firstGameActivity = activity;
		//上报游戏时长使用
		ReportEvent.sGameStart = System.currentTimeMillis() / 1000;
		CrashReportApi.init(activity.getApplicationContext());
		CrashReportApi.startMSDKStatus(GameStatus.MSDK_INIT);
		
		this.qq_appid = baseInfo.qqAppId;
		this.qqAppKey = baseInfo.qqAppKey;
		this.wx_appid = baseInfo.wxAppId;
		this.msdkKey = baseInfo.msdkKey;
		this.offerId = baseInfo.offerId;
		this.appVersionName = baseInfo.appVersionName;
		this.appVersionCode = baseInfo.appVersionCode;
		
		this.mFirstStart = true;
		this.api = WXAPIFactory.createWXAPI(mActivity, wx_appid);
		this.api.registerApp(wx_appid);
		this.mTencent = Tencent.createInstance(this.qq_appid,
				activity.getApplicationContext());
		mStat.init(activity, baseInfo.qqAppId);
		threadMgn = MsdkThreadManager.getInstance();
		threadMgn.init();
		threadMgn.sendGetPermissionMsg();
		// 初始化webview
		WebViewManager.getInstance().init(mActivity, this.qq_appid);
		// 初始化切换msdk push开关
		boolean bTestEnv = isTestEnv();
		SwitcherManager.getInstance().init(mActivity);
		// 调用之前先调用SwitcherManager
		PushSwitchMng.getInstance().init(mActivity, this.qq_appid, this.qqAppKey, this.wx_appid, bTestEnv);
		ADManager.getInstance().init(mActivity);
		Logger.d("Initialized end: " + this.wx_appid + "-" + this.qq_appid);
		Logger.d("WeGameSDK Version: " + this.WGGetVersion());
		
		if (bTestEnv) {
		    MsdkDoctor doctor = new MsdkDoctor(WeGame.getInstance().getActivity());
		    ArrayList<String> checkResult = doctor.checkAll();
		    StringBuilder resultBuilder = new StringBuilder();
		    if (null != checkResult && checkResult.size() != 0) {
		        Logger.w("MSDK Config Error!!!!");
		        Logger.w("Check Result: " + checkResult.size());
		        Logger.d("********************check result start********************");
		        for (String errorMsg: checkResult) {
		            Logger.w(errorMsg);
		            resultBuilder.append(errorMsg);
		        }
		        Logger.d("********************check result end**********************");
		    } else {
		    	Logger.w("Check Result: " + checkResult.size());
		        Logger.d("All Config OK!!!");
		    }

			Toast.makeText(getActivity(), "You are using " + getApiDomain(), Toast.LENGTH_LONG).show();
			boolean isPauseCalled = SharedPreferencesTool.getBoolean(getActivity(), "ON_PAUSE_CALLED", false);
			boolean isResumeCalled = SharedPreferencesTool.getBoolean(getActivity(), "ON_RESUME_CALLED", false);
			if(!isPauseCalled || !isResumeCalled) {
			    //Toast.makeText(getActivity(), "You must call WGPlatform.onPause and WGPlatform.onResume", Toast.LENGTH_LONG).show();
			}
            HashMap<String, String> map = new HashMap<String, String>();
            map.put("qqAppId", baseInfo.qqAppId);
            map.put("qqAppKey", baseInfo.qqAppKey);
            map.put("wxAppid", baseInfo.wxAppId);
            map.put("msdkKey", baseInfo.msdkKey);
            map.put("offerId", baseInfo.offerId);
            map.put("actName", activity.getClass().getName());
            map.put("doctor", resultBuilder.toString());
            SaveLogHelper.getInstance().reportLog("Initialized", map, false);
		}
		// 获取公告
		NoticeManager.getInstance().init(this.mActivity);

		// 要给应用白名单sdk最新的context
		WhiteListMng.gDefault.get().setmContext(getActivity());

		if ("true".equals(ConfigManager.readValueByKey(getActivity(),
				"SAVE_UPDATE"))) {
			AutoUpdateManager.init();
		}

		// 调用注册设备
		PushSwitchMng.getInstance().registerAppPush();
		
		TaskManager.getInstance().startTimer();
		TaskManager.getInstance().addRunningTask(new NoticeTask(TaskNameConst.NOTICE_TASK));
		TaskManager.getInstance().addRunningTask(new ADTask(TaskNameConst.AD_TASK));
		
		MsdkStat.gDefault.get().clearReportStatus();
		LoginManager.getInstance().init(this.mActivity);
		// 此处初始化登录timer
		LoginTimer.getInstance().initTimer(this.mActivity);
		logPlatformSDKVersion();
		
		registerADReportReceiver();
		CrashReportApi.endMSDKStatus(GameStatus.MSDK_INIT,0,0);
	}
	
	private boolean isTestEnv() {
		String domain = getApiDomain();
	    return domain.contains("test") || domain.contains("dev");
	}

	
    public Tencent getTencent(){
	    return mTencent;
	}
	
	public Stat getStat() {
		return this.mStat;
	}

	public String getQQAPPKey() {
		return this.qqAppKey;
	}
	
	public String getMSDKKey() {
		return this.msdkKey;
	}
	
	// 设置java层委托
	public void setObserver(WGPlatformObserver observer) {
		WeGameNotifyGame.getInstance().setObserver(observer);
	}

    public void setADObserver(WGADObserver observer) {
        WeGameNotifyGame.getInstance().setADObserver(observer);
    }
    
    public void setGroupObserver(WGGroupObserver observer) {
        WeGameNotifyGame.getInstance().setGroupObserver(observer);
    }
	   
	//判断拉起平台是否为QQ游戏大厅
	public boolean wakeUpFromHall(Intent intent) {
	    // 金刚安全检测，因此getExtras添加try...catch处理
	    try{
            if (intent == null || intent.getExtras() == null) {
                Logger.d("wakeUpFromHall" + "intent is NULL");
                return false;
            }
            Bundle b = intent.getExtras();
            Set<String> keys = b.keySet();
            if (keys.contains("KEY_START_FROM_HALL")) {
                return true;
            } else {
                return false;
            }
	    }catch(Exception e){
	        e.printStackTrace();
	        return false;
	    }
	}



	/**
	 * @param intent
	 */
	public void handleCallback(Intent intent) {
		CrashReportApi.setApplicationStatus(GameStatus.MSDK_GOFRONT);
		Logger.d("handleCallBack");
		// 手动启动, 不处理callback
		Bundle extras = new Bundle();
		try{
            if (intent == null || intent.getExtras() == null) {
                Logger.d("handleCallBack" + "intent is NULL");
                return;
            }
            Logger.d(intent);
            // 即使getExtras()也有可能是手动启动, 取决于游戏是否设置putExtras
            extras.putAll(intent.getExtras());
            Set<String> keys = intent.getExtras().keySet();
            for (String key : keys) {
                Logger.d("remove " + key);
                intent.removeExtra(key);
            }
		} catch(Exception e) {
		    // 金刚要求getExtras都必须try...catch
		    e.printStackTrace();
		}
		
		Logger.d(intent);
		mActivity.setIntent(intent);
        LoginManager.getInstance().handleCallback(extras);
	}
	
	public void WGSetPermission(int permissions) {
		Logger.d("WGSetQzonePermission + permissions: " + permissions);
		String[] permissionStr = WGQZonePermissions
				.getPermissionStr(permissions);
		ArrayList<String> list = new ArrayList<String>(
				Arrays.asList(permissionStr));
		// Remove all empty values
		list.removeAll(Arrays.asList("", null));
		StringBuilder builder = new StringBuilder();

		for (int i = 0; i < list.size(); i++) {
			if (i > 0) {
				builder.append(", ");
			}
			builder.append(list.get(i));
		}
		mPermission = builder.toString();
		Logger.d("mPermission: " + mPermission);
	}

	public int getFlag() {
		return this.flag;
	}

	public int getPlatId() {
		return mPlatId;
	}

	public void setFlag(int flag) {
		this.flag = flag;
	}

	public void setPlatId(int platId) {
		this.mPlatId = platId;
	}

	public void setOpenSdkLoginInfo(String openId, String atoken,
			long actExpired) {
		if (openId == null) {
			openId = "";
		}
		if (atoken == null) {
			atoken = "";
		}
		mTencent.setOpenId(openId);
		mTencent.setAccessToken(atoken, "" + actExpired);
	}

	public Activity getActivity() {
		return mActivity;
	}

	/** 拉起微信获取token信息 **/
	public void lauchWXPlatForm() {
		Logger.d("lauchWXPlatForm");
		WeGame.getInstance().mPlatId = WXPLATID;
		int code = this.checkWXEnv();

		switch (code) {
		case CallbackFlag.eFlag_WX_NotInstall: {
			LoginRet lr = new LoginRet();
			lr.platform = WeGame.getInstance().getPlatId();
			lr.desc = "Weixin NOT Installed";
			lr.flag = CallbackFlag.eFlag_WX_NotInstall;
			WeGameNotifyGame.getInstance().OnPlatformLoginNotify(lr);
			HashMap<String, String> map = new HashMap<String, String>();
	        map.put("plat", String.valueOf(lr.platform));
	        map.put("desc", lr.desc);
	        map.put("flag", String.valueOf(lr.flag));
	        SaveLogHelper.getInstance().reportLog("WGLogin", map, true);
			return;
		}
		case CallbackFlag.eFlag_WX_NotSupportApi: {
			LoginRet lr = new LoginRet();
			lr.platform = WeGame.getInstance().getPlatId();
			lr.desc = "Weixin API NOT Support";
			lr.flag = CallbackFlag.eFlag_WX_NotSupportApi;
			WeGameNotifyGame.getInstance().OnPlatformLoginNotify(lr);
			HashMap<String, String> map = new HashMap<String, String>();
            map.put("plat", String.valueOf(lr.platform));
            map.put("desc", lr.desc);
            map.put("flag", String.valueOf(lr.flag));
            SaveLogHelper.getInstance().reportLog("WGLogin", map, true);
			return;
		}
		}

		wxRequestStartTime = System.currentTimeMillis();
		final SendAuth.Req req = new SendAuth.Req();
		req.scope = "snsapi_userinfo,snsapi_friend,snsapi_message";
		req.state = "none";

		Logger.d("wexin sendReq");
		boolean ret = WeGame.getInstance().api.sendReq(req);
		Logger.d("lauchWXPlatForm wx SendReqRet: " + ret);
		
		// 如果是false不会到达到微信拉起部分
        if (!ret) {
            LoginRet lr = new LoginRet();
            lr.platform = WeGame.getInstance().getPlatId();
            lr.desc = "Weixin login fail, sendReq false";
            lr.flag = CallbackFlag.eFlag_WX_LoginFail;
            WeGameNotifyGame.getInstance().OnPlatformLoginNotify(lr);
        }
	}

	private int checkWXEnv() {
		if (!WeGame.getInstance().api.isWXAppInstalled()) {
			Logger.d("weixin not install");
			return CallbackFlag.eFlag_WX_NotInstall;
		}
		if (!WeGame.getInstance().api.isWXAppSupportAPI()) {
			Logger.d("weixin not support api");
		}
		return CallbackFlag.eFlag_Succ;
	}

	public int checkQQEnv() {
		return CallbackFlag.eFlag_Succ;
	}

	public void login(int platform) {
		WhiteListMng.gDefault.get().cleanWhiteListUserinfoCache();
		MsdkStat.gDefault.get().clearReportStatus();
		if (platform == WXPLATID) {
			setPlatId(WXPLATID);
			lauchWXPlatForm();
		} else if (platform == QQPLATID) {
			setPlatId(QQPLATID);
			//lauchQQPlatForm();
			new QQLogin().lauchQQPlatForm();
		} else {
			Logger.e("Wrong platformId");
		}
	}

	// /**注销登录**/
	public boolean logout() {
		Logger.d("logout ");
		// 清空openid
		this.mStat.resetOpenId();
		// 登出以后pf不在有效, 如果需要需要重新取,在登出时清空之
		WGPfManager.getInstance().clearPfAndPfKey();
		LoginRet lr = LoginInfoManager.getInstance().getLastLoginUserInfo();
		if (lr.platform != 0) {
			mPlatId = lr.platform;// 设置平台
			LoginInfoManager.getInstance().deleteLoginRecord(lr.open_id);
		}

		if (mPlatId == QQPLATID) {
			this.setPlatId(0);// 此处为bug，之前会导致帐号注销失败。
			if (mTencent == null)
				return false;
			if (!mTencent.isSessionValid())
				return false;
			mTencent.logout(mActivity);
		} else if (mPlatId == WXPLATID) {
			this.setPlatId(0);
			if (api == null)
				return false;
			api.unregisterApp();
		}
		return true;
	}

	protected String setExpiresTime(String expiresTime) {
		return (System.currentTimeMillis() + Long.parseLong(expiresTime) * 1000)
				+ "";
	}

	protected long getExpiresTime(String expiresTime) {
		return (Long.parseLong(expiresTime) - System.currentTimeMillis()) / 1000;
	}
	
	   
    /**
     * @param title 结构化消息的标题
     * @param desc 结构化消息的概要信息
     * @param url 分享的URL
     * @param mediaTagName 请根据实际情况填入下列值的一个, 此值会传到微信供统计用, 在分享返回时也会带回此值, 可以用于区分分享来源
     "MSG_INVITE";                   // 邀请
     "MSG_SHARE_MOMENT_HIGH_SCORE";    //分享本周最高到朋友圈
     "MSG_SHARE_MOMENT_BEST_SCORE";    //分享历史最高到朋友圈
     "MSG_SHARE_MOMENT_CROWN";         //分享金冠到朋友圈
     "MSG_SHARE_FRIEND_HIGH_SCORE";     //分享本周最高给好友
     "MSG_SHARE_FRIEND_BEST_SCORE";     //分享历史最高给好友
     "MSG_SHARE_FRIEND_CROWN";          //分享金冠给好友
     "MSG_friend_exceed"         // 超越炫耀
     "MSG_heart_send"            // 送心
     * @param thumbImgData 结构化消息的缩略图
     * @param thumbImgDataLen 结构化消息的缩略图数据长度
     * @param messageExt 游戏分享是传入字符串，通过此消息拉起游戏会通过 OnWakeUpNotify(WakeupRet ret)中ret.messageExt回传给游戏
     * @return void
     *   通过游戏设置的全局回调的OnShareNotify(ShareRet& shareRet)回调返回数据给游戏, shareRet.flag值表示返回状态, 可能值及说明如下:
     *     eFlag_Succ: 分享成功
     *     eFlag_Error: 分享失败
     */
	public void WGSendToWeixinWithUrl(int scene, String title, String desc,
			String url, String mediaTagName, byte[] thumbImgData,
			int thumbImgDataLen, String messageExt) {
		Logger.d("WGSendToWeixinWithUrl " + scene);
		int code = this.checkWXEnv();

		switch (code) {
		case CallbackFlag.eFlag_WX_NotInstall: {
			ShareRet sr = new ShareRet();
			sr.platform = WeGame.getInstance().getPlatId();
			sr.desc = "Weixin NOT Installed";
			sr.flag = CallbackFlag.eFlag_WX_NotInstall;
			Logger.d("sendtoweixin notify, flag:" + sr.flag + ",platform:" + sr.platform); 
			return;
		}
		case CallbackFlag.eFlag_WX_NotSupportApi: {
			ShareRet sr = new ShareRet();
			sr.platform = WeGame.getInstance().getPlatId();
			sr.desc = "Weixin API NOT Support";
			sr.flag = CallbackFlag.eFlag_WX_NotSupportApi;
			Logger.d("sendtoweixin notify, flag:" + sr.flag + ",platform:" + sr.platform); 
			return;
		}
		}

		if (thumbImgData == null || thumbImgDataLen == 0) {
			Logger.e("thumbImgData should NOT BE NULL and thumbImgDataLen !== 0");
			return;
		}

		Logger.d("thumbImgData: " + thumbImgData.length + ";thumbImgDataLen: " + thumbImgDataLen);
		if (thumbImgData.length > THUMB_MAX_SIZE) {
			Logger.w("thumbImgData too big, it should be less than 32K");
		}

		Bitmap bmp = BitmapFactory.decodeByteArray(thumbImgData, 0, thumbImgDataLen);
		if(null == bmp){
			Logger.e("thumbImgData decode to bmp error!");
			return;
		}
		float w = bmp.getWidth();
		float h = bmp.getHeight();

		Bitmap thumbBmp = null;
		if (w > h) {
			thumbBmp = Bitmap.createScaledBitmap(bmp, THUMB_SIZE,
					(int) (THUMB_SIZE * (h / w)), true);
		} else {
			thumbBmp = Bitmap.createScaledBitmap(bmp,
					(int) (THUMB_SIZE * (w / h)), THUMB_SIZE, true);
		}
		ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
		thumbBmp.compress(Bitmap.CompressFormat.JPEG, 90, byteStream);

		WXWebpageObject webpage = new WXWebpageObject();
		webpage.webpageUrl = url;
		WXMediaMessage msg = new WXMediaMessage(webpage);
		msg.title = title;
		msg.description = desc;
		msg.thumbData = byteStream.toByteArray();
		msg.messageExt = messageExt;
		SendMessageToWX.Req req = new SendMessageToWX.Req();
		LoginRet lr = new LoginRet();
		LoginUtils.getLocalLoginRet(lr);
		// 只有微信的账号才进行异账号提醒
		if(lr.platform == WeGame.WXPLATID) {
		    req.openId = lr.open_id;
		} else {
		    req.openId = "";
		}
		req.transaction = "webpage";
		req.message = msg;
		req.scene = scene;

		Logger.d("WGSendToWeixinWithUrl" + "sendReq with openid  " + req.openId);
		boolean isSendReqSucc = WeGame.getInstance().api.sendReq(req);
		Logger.d("WGSendToWeixinWithUrl isSendReqSucc: " + isSendReqSucc);
	}
	/**
	 * 
	 * @param scene
	 *            指定分享到朋友圈还是分享给特定好友
	 * @param title
	 * @param desc
	 * @param webpageUrl
	 *            点击跳转的url
	 * @param mediaTagName
	 *            一般可填写webpage
	 * @param imgData
	 *            缩略图不超过32K
	 */
	public void sendToWeixinWithUrl(int scene, String title, String desc,
			String webpageUrl, String mediaTagName, byte[] imgData,
			int imgDataLen) {
		Logger.d("WGSendToWeixinWithUrl " + scene);
		int code = this.checkWXEnv();

		switch (code) {
		case CallbackFlag.eFlag_WX_NotInstall: {
			ShareRet sr = new ShareRet();
			sr.platform = WeGame.getInstance().getPlatId();
			sr.desc = "Weixin NOT Installed";
			sr.flag = CallbackFlag.eFlag_WX_NotInstall;
			Logger.d("sendtoweixin notify, flag:" + sr.flag + ",platform:" + sr.platform); 
			return;
		}
		case CallbackFlag.eFlag_WX_NotSupportApi: {
			ShareRet sr = new ShareRet();
			sr.platform = WeGame.getInstance().getPlatId();
			sr.desc = "Weixin API NOT Support";
			sr.flag = CallbackFlag.eFlag_WX_NotSupportApi;
			Logger.d("sendtoweixin notify, flag:" + sr.flag + ",platform:" + sr.platform); 
			return;
		}
		}

		if (imgData == null || imgDataLen == 0) {
			Logger.e("imgData should NOT BE NULL and imgDataLen !== 0");
			return;
		}

		Logger.d("imgData: " + imgData.length + ";imgDataLen: " + imgDataLen);
		if (imgData.length > THUMB_MAX_SIZE) {
			Logger.w("imgData too big, it should be less than 32K");
		}

		Bitmap bmp = BitmapFactory.decodeByteArray(imgData, 0, imgDataLen);
		if(null == bmp){
			Logger.e("imgData decode to bmp error!");
			return;
		}
		float w = bmp.getWidth();
		float h = bmp.getHeight();

		Bitmap thumbBmp = null;
		if (w > h) {
			thumbBmp = Bitmap.createScaledBitmap(bmp, THUMB_SIZE,
					(int) (THUMB_SIZE * (h / w)), true);
		} else {
			thumbBmp = Bitmap.createScaledBitmap(bmp,
					(int) (THUMB_SIZE * (w / h)), THUMB_SIZE, true);
		}
		ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
		thumbBmp.compress(Bitmap.CompressFormat.JPEG, 90, byteStream);

		WXWebpageObject webpage = new WXWebpageObject();
		webpage.webpageUrl = webpageUrl;
		WXMediaMessage msg = new WXMediaMessage(webpage);
		msg.title = title;
		msg.description = desc;
		msg.thumbData = byteStream.toByteArray();

		SendMessageToWX.Req req = new SendMessageToWX.Req();
		LoginRet lr = new LoginRet();
		LoginUtils.getLocalLoginRet(lr);
		// 只有微信的账号才进行异账号提醒
		if(lr.platform == WeGame.WXPLATID) {
		    req.openId = lr.open_id;
		} else {
		    req.openId = "";
		}
		req.transaction = "msdkwebpage";
		req.message = msg;
		req.scene = scene;

		Logger.d("WGSendToWeixinWithUrl" + "sendReq with openid  " + req.openId);
		boolean isSendReqSucc = WeGame.getInstance().api.sendReq(req);
		Logger.d("WGSendToWeixinWithUrl isSendReqSucc: " + isSendReqSucc);
	}

	/**
	 * @param scene
	 *            指定分享到朋友圈还是分享给特定好友
	 * @param title
	 *            分享标题
	 * @param desc
	 *            分享描述
	 * @param ur
	 *            点击跳转的url
	 * @param mediaTagName
	 *            一般可填写webpage
	 * @param imgData
	 *            缩略图不超过32K
	 */
	public void WGSendToWeixin(int scene, String title, String desc,
			String url, String mediaTagName, byte[] imgData, int imgDataLen) {
		Logger.d("WGSendToWeixin：" + scene);
		int code = this.checkWXEnv();

		switch (code) {
		case CallbackFlag.eFlag_WX_NotInstall: {
			ShareRet sr = new ShareRet();
			sr.platform = WeGame.getInstance().getPlatId();
			sr.desc = "Weixin NOT Installed";
			sr.flag = CallbackFlag.eFlag_WX_NotInstall;
			WeGameNotifyGame.getInstance().OnShareNotify(sr);
			return;
		}
		case CallbackFlag.eFlag_WX_NotSupportApi: {
			ShareRet sr = new ShareRet();
			sr.platform = WeGame.getInstance().getPlatId();
			sr.desc = "Weixin API NOT Support";
			sr.flag = CallbackFlag.eFlag_WX_NotSupportApi;
			WeGameNotifyGame.getInstance().OnShareNotify(sr);
			return;
		}
		}

		if (imgData == null || imgDataLen == 0) {
			Logger.e("imgData should NOT BE NULL and imgDataLen !== 0");
			return;
		}

		Logger.d("imgData: " + imgData.length + ";imgDataLen: " + imgDataLen);
		if (imgData.length > THUMB_MAX_SIZE) {
		    Logger.w("imgData is large than 32K, it will be compress");
            
            BitmapFactory.Options options = new BitmapFactory.Options();
            options.inJustDecodeBounds = true;
            BitmapFactory.decodeByteArray(imgData, 0, imgDataLen, options);
            
            int w = options.outWidth;
            int h = options.outHeight;
            Bitmap thumbBmp = null;
            if (w > h) {
                options.outWidth = THUMB_SIZE;
                options.outHeight = (int) (h * THUMB_SIZE / w) ;
                options.inSampleSize = w / 200;
                options.inJustDecodeBounds = false;
                thumbBmp = BitmapFactory.decodeByteArray(imgData, 0, imgDataLen, options);
            } else {
                options.outHeight = THUMB_SIZE;
                options.outWidth = (int) (w * THUMB_SIZE / h) ;
                options.inSampleSize = h / 200;
                options.inJustDecodeBounds = false;
                thumbBmp = BitmapFactory.decodeByteArray(imgData, 0, imgDataLen, options);
            }
            if(null == thumbBmp){
                Logger.e("imgData decode to thumbBmp error!");
                return;
            }
            // 尝试压缩到合适的大小
            int ratio[] = {95, 90, 80, 60, 20, 5, 2, 1};
            int index = 0;
            ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
            thumbBmp.compress(Bitmap.CompressFormat.JPEG, ratio[index++], byteStream);
            while (byteStream.size() > THUMB_MAX_SIZE && index < ratio.length) {
                byteStream.reset();
                thumbBmp.compress(Bitmap.CompressFormat.JPEG, ratio[index++], byteStream);
            }
            if (index >= ratio.length) {
                Logger.d("compress image faild!");
                return;
            }
            try {
                imgData = byteStream.toByteArray();
                byteStream.close();
            } catch (IOException e) {
                Logger.w("close byteStream exception:" + e.getMessage());
            }
            thumbBmp.recycle();
            Logger.d("send imgData length is " + imgData.length);
		}

		WXAppExtendObject appData = new WXAppExtendObject();

		if (!T.ckIsEmpty(mediaTagName)) {
			appData.extInfo = mediaTagName;
		} else {
			appData.extInfo = Consts.EMPTY_MEDIA_TAG_NAME;
		}

		WXMediaMessage msg = new WXMediaMessage();
		msg.title = title;
		msg.description = desc;
		msg.mediaObject = appData;
		msg.mediaTagName = mediaTagName;

		msg.thumbData = imgData;

		SendMessageToWX.Req req = new SendMessageToWX.Req();
		LoginRet lr = new LoginRet();
		LoginUtils.getLocalLoginRet(lr);
		req.openId = lr.open_id;
		req.transaction = "appdata";
		req.message = msg;
		req.scene = scene;

		Logger.d("WGSendToWinxin" + "sendReq with openid  " + req.openId);
		boolean isSendReqSucc = WeGame.getInstance().api.sendReq(req);
		Logger.d("WGSendToWeixin isSendReqSucc: " + isSendReqSucc);
	}

	// messageAction=WECHAT_SNS_JUMP_SHOWRANK 跳排行
	// messageAction=WECHAT_SNS_JUMP_URL 跳链接
	// messageAction=WECHAT_SNS_JUMP_APP 跳APP
	/**
	 * @param params
	 *            微信分享需要的基本参数
	 * @param scene
	 *            指定分享到朋友圈还是分享给特定好友
	 * @return int 返回码标识 微信是否安装, 微信版本是否支持api
	 */
	public void WGSendToWeixin(String title, String desc, String mediaTagName,
			byte[] imgData, int imgDataLen, String messageExt) {
		Logger.d("WGSendToWeixin ");
		int code = this.checkWXEnv();

		switch (code) {
    		case CallbackFlag.eFlag_WX_NotInstall: {
    			ShareRet sr = new ShareRet();
    			sr.platform = WeGame.getInstance().getPlatId();
    			sr.desc = "Weixin NOT Installed";
    			sr.flag = CallbackFlag.eFlag_WX_NotInstall;
    			WeGameNotifyGame.getInstance().OnShareNotify(sr);
    			return;
    		}
    		case CallbackFlag.eFlag_WX_NotSupportApi: {
    			ShareRet sr = new ShareRet();
    			sr.platform = WeGame.getInstance().getPlatId();
    			sr.desc = "Weixin API NOT Support";
    			sr.flag = CallbackFlag.eFlag_WX_NotSupportApi;
    			WeGameNotifyGame.getInstance().OnShareNotify(sr);
    			return;
    		}
		}

		if (imgData == null || imgDataLen == 0) {
			Logger.e("imgData should NOT BE NULL and imgDataLen !== 0");
			return;
		}

		Logger.d("imgData: " + imgData.length + ";imgDataLen: " + imgDataLen);
		if (imgData.length > THUMB_MAX_SIZE) {
			Logger.w("imgData is large than 32K, it will be compress");
			
			BitmapFactory.Options options = new BitmapFactory.Options();
			options.inJustDecodeBounds = true;
			BitmapFactory.decodeByteArray(imgData, 0, imgDataLen, options);
            
            int w = options.outWidth;
            int h = options.outHeight;
            Bitmap thumbBmp = null;
            if (w > h) {
                options.outWidth = THUMB_SIZE;
                options.outHeight = (int) (h * THUMB_SIZE / w) ;
                options.inSampleSize = w / 200;
                options.inJustDecodeBounds = false;
                thumbBmp = BitmapFactory.decodeByteArray(imgData, 0, imgDataLen, options);
            } else {
                options.outHeight = THUMB_SIZE;
                options.outWidth = (int) (w * THUMB_SIZE / h) ;
                options.inSampleSize = h / 200;
                options.inJustDecodeBounds = false;
                thumbBmp = BitmapFactory.decodeByteArray(imgData, 0, imgDataLen, options);
            }
            if(null == thumbBmp){
                Logger.e("imgData decode to thumbBmp error!");
                return;
            }
            // 尝试压缩到合适的大小
            int ratio[] = {95, 90, 80, 60, 20, 5, 2, 1};
            int index = 0;
            ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
            thumbBmp.compress(Bitmap.CompressFormat.JPEG, ratio[index++], byteStream);
            while (byteStream.size() > THUMB_MAX_SIZE && index < ratio.length) {
                byteStream.reset();
                thumbBmp.compress(Bitmap.CompressFormat.JPEG, ratio[index++], byteStream);
            }
            if (index >= ratio.length) {
                Logger.d("compress image faild!");
                return;
            }
            try {
                imgData = byteStream.toByteArray();
                byteStream.close();
            } catch (IOException e) {
                Logger.w("close byteStream exception:" + e.getMessage());
            }
            thumbBmp.recycle();
            Logger.d("imgData length is " + imgData.length);
		}

		WXAppExtendObject appData = new WXAppExtendObject();

		if (!T.ckIsEmpty(mediaTagName)) {
			appData.extInfo = mediaTagName;
		} else {
			appData.extInfo = Consts.EMPTY_MEDIA_TAG_NAME;

		}

		WXMediaMessage msg = new WXMediaMessage();
		msg.title = title;
		msg.description = desc;
		msg.mediaObject = appData;
		msg.mediaTagName = mediaTagName;
		msg.thumbData = imgData;
		msg.messageExt = messageExt;
		SendMessageToWX.Req req = new SendMessageToWX.Req();
		LoginRet lr = new LoginRet();
		LoginUtils.getLocalLoginRet(lr);
		req.openId = lr.open_id;
		req.transaction = "appdata";
		req.message = msg;
		req.scene = SendMessageToWX.Req.WXSceneSession;

		Logger.d("WGSendToWinxin" + "sendReq with openid  " + req.openId);
		boolean isSendReqSucc = WeGame.getInstance().api.sendReq(req);
		Logger.d("WGSendToWeixin isSendReqSucc: " + isSendReqSucc);
	}

	public void WGSendToWeixinWithPhoto(int scene, String mediaTagName,
			byte[] imgData, int imgDataLen) {
		Logger.d("" + "WGSendToWeixinWithPhoto scene: " + scene);
		int code = this.checkWXEnv();

		switch (code) {
		case CallbackFlag.eFlag_WX_NotInstall: {
			ShareRet sr = new ShareRet();
			sr.platform = WeGame.getInstance().getPlatId();
			sr.desc = "Weixin NOT Installed";
			sr.flag = CallbackFlag.eFlag_WX_NotInstall;
			WeGameNotifyGame.getInstance().OnShareNotify(sr);
			return;
		}
		case CallbackFlag.eFlag_WX_NotSupportApi: {
			ShareRet sr = new ShareRet();
			sr.platform = WeGame.getInstance().getPlatId();
			sr.desc = "Weixin API NOT Support";
			sr.flag = CallbackFlag.eFlag_WX_NotSupportApi;
			WeGameNotifyGame.getInstance().OnShareNotify(sr);
			return;
		}
		}

		if (imgData == null || imgDataLen == 0) {
			Logger.e("imgData should NOT BE NULL and imgDataLen !== 0");
			return;
		}
		
		Logger.d("imgData: " + imgData.length + ";imgDataLen: " + imgDataLen);
		if (imgData.length > IMG_MAX_SIZE) {
			Logger.w("imgData too big, it should be less than 10M");
		}

		Bitmap bmp = BitmapFactory.decodeByteArray(imgData, 0, imgDataLen);
		if(null == bmp){
			Logger.e("imgData decode to bmp error!");
			return;
		}
		float w = bmp.getWidth();
		float h = bmp.getHeight();

		Bitmap thumbBmp = null;
		if (w > h) {
			thumbBmp = Bitmap.createScaledBitmap(bmp, THUMB_SIZE,
					(int) (THUMB_SIZE * (h / w)), true);
		} else {
			thumbBmp = Bitmap.createScaledBitmap(bmp,
					(int) (THUMB_SIZE * (w / h)), THUMB_SIZE, true);
		}
		ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
		thumbBmp.compress(Bitmap.CompressFormat.JPEG, 90, byteStream);

		WXImageObject wxImg = new WXImageObject(bmp);

		WXMediaMessage msg = new WXMediaMessage();
		msg.mediaObject = wxImg;
		msg.thumbData = byteStream.toByteArray();
		msg.mediaTagName = mediaTagName;

		Logger.d("imgData " + imgData.length);
		Logger.d("thumbData " + byteStream.toByteArray().length);

		SendMessageToWX.Req req = new SendMessageToWX.Req();
		LoginRet lr = new LoginRet();
		LoginUtils.getLocalLoginRet(lr);
		req.openId = lr.open_id;
		req.transaction = "img";
		req.message = msg;
		req.scene = scene;

		Logger.d("WGSendToWinxin" + "sendReq with openid  " + req.openId);
		boolean isSendReqSucc = WeGame.getInstance().api.sendReq(req);
		Logger.d("WGSendToWeixin isSendReqSucc: " + isSendReqSucc);
	}

	public void WGSendToWeixinWithPhoto(int scene, String mediaTagName,
			byte[] imgData, int imgDataLen, String messageExt, String mediaAction) {
		Logger.d("" + "WGSendToWeixinWithPhoto scene: " + scene);
		int code = this.checkWXEnv();

		switch (code) {
		case CallbackFlag.eFlag_WX_NotInstall: {
			ShareRet sr = new ShareRet();
			sr.platform = WeGame.getInstance().getPlatId();
			sr.desc = "Weixin NOT Installed";
			sr.flag = CallbackFlag.eFlag_WX_NotInstall;
			WeGameNotifyGame.getInstance().OnShareNotify(sr);
			return;
		}
		case CallbackFlag.eFlag_WX_NotSupportApi: {
			ShareRet sr = new ShareRet();
			sr.platform = WeGame.getInstance().getPlatId();
			sr.desc = "Weixin API NOT Support";
			sr.flag = CallbackFlag.eFlag_WX_NotSupportApi;
			WeGameNotifyGame.getInstance().OnShareNotify(sr);
			return;
		}
		}

		if (imgData == null || imgDataLen == 0) {
			Logger.e("imgData should NOT BE NULL and imgDataLen !== 0");
			return;
		}
		Logger.d("imgData: " + imgData.length + ";imgDataLen: " + imgDataLen);
		if (imgData.length > IMG_MAX_SIZE) {
			Logger.w("imgData too big, it should be less than 10M");
		}
		Bitmap bmp = BitmapFactory.decodeByteArray(imgData, 0, imgDataLen);
		if(null == bmp){
			Logger.e("imgData decode to bmp error!");
			return;
		}
		float w = bmp.getWidth();
		float h = bmp.getHeight();

		Bitmap thumbBmp = null;
		if (w > h) {
			thumbBmp = Bitmap.createScaledBitmap(bmp, THUMB_SIZE,
					(int) (THUMB_SIZE * (h / w)), true);
		} else {
			thumbBmp = Bitmap.createScaledBitmap(bmp,
					(int) (THUMB_SIZE * (w / h)), THUMB_SIZE, true);
		}
		ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
		thumbBmp.compress(Bitmap.CompressFormat.JPEG, 90, byteStream);

		WXImageObject wxImg = new WXImageObject(bmp);

		WXMediaMessage msg = new WXMediaMessage();
		msg.mediaObject = wxImg;
		msg.thumbData = byteStream.toByteArray();
		msg.mediaTagName = mediaTagName;
		msg.messageExt = messageExt;
		msg.messageAction = mediaAction;

		Logger.d("imgData " + imgData.length);
		Logger.d("thumbData " + byteStream.toByteArray().length);

		SendMessageToWX.Req req = new SendMessageToWX.Req();
		LoginRet lr = new LoginRet();
		LoginUtils.getLocalLoginRet(lr);
		req.openId = lr.open_id;
		req.transaction = "img";
		req.message = msg;
		req.scene = scene;
		boolean isSendReqSucc = WeGame.getInstance().api.sendReq(req);
		Logger.d("WGSendToWeixin isSendReqSucc: " + isSendReqSucc);
	}
	
	public void WGSendToWeixinWithPhotoPath(int scene, String mediaTagName,
            String imgPath, String messageExt, String mediaAction) {
        Logger.d("" + "WGSendToWeixinWithPhoto scene: " + scene);
        int code = this.checkWXEnv();

        switch (code) {
            case CallbackFlag.eFlag_WX_NotInstall: {
                ShareRet sr = new ShareRet();
                sr.platform = WeGame.getInstance().getPlatId();
                sr.desc = "Weixin NOT Installed";
                sr.flag = CallbackFlag.eFlag_WX_NotInstall;
                WeGameNotifyGame.getInstance().OnShareNotify(sr);
                return;
            }
            case CallbackFlag.eFlag_WX_NotSupportApi: {
                ShareRet sr = new ShareRet();
                sr.platform = WeGame.getInstance().getPlatId();
                sr.desc = "Weixin API NOT Support";
                sr.flag = CallbackFlag.eFlag_WX_NotSupportApi;
                WeGameNotifyGame.getInstance().OnShareNotify(sr);
                return;
            }
        }

        File file = new File(imgPath);
        if (!file.exists()) {
            Logger.e(imgPath + " is not exist!");
            return;
        }
        long imgSize = file.length();
        if (imgSize > IMG_LIMIT_SIZE) {
            Logger.w("image should be smaller than 3M!");
        }
        
        Bitmap bmp = BitmapFactory.decodeFile(imgPath);
        Bitmap thumbBmp;
        float w = bmp.getWidth();
        float h = bmp.getHeight();
        if (w > h) {
            thumbBmp = Bitmap.createScaledBitmap(bmp, THUMB_SIZE,
                    (int) (THUMB_SIZE * (h / w)), true);
        } else {
            thumbBmp = Bitmap.createScaledBitmap(bmp,
                    (int) (THUMB_SIZE * (w / h)), THUMB_SIZE, true);
        }
        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
        thumbBmp.compress(Bitmap.CompressFormat.JPEG, 90, byteStream);
        bmp.recycle();
        
        WXImageObject imgObj = new WXImageObject();
        imgObj.setImagePath(imgPath);
        
        WXMediaMessage msg = new WXMediaMessage();
        msg.mediaObject = imgObj;
        msg.thumbData = byteStream.toByteArray();
        msg.mediaTagName = mediaTagName;
        msg.messageExt = messageExt;
        msg.messageAction = mediaAction;
        
        Logger.d("imageData " + imgSize);
        Logger.d("thumbData " + byteStream.toByteArray().length);
        
        SendMessageToWX.Req req = new SendMessageToWX.Req();
        LoginRet lr = new LoginRet();
        LoginUtils.getLocalLoginRet(lr);
        req.openId = lr.open_id;
        req.transaction = "img";
        req.message = msg;
        req.scene = scene;
        
        boolean isSendReqSucc = WeGame.getInstance().api.sendReq(req);
        Logger.d("WGSendToWeixin isSendReqSucc: " + isSendReqSucc);
    }


	/**
	 * @param scene
	 *            指定分享到朋友圈, 或者微信会话, 可能值和作用如下: WechatScene_Session: 分享到微信会话
	 *            WechatScene_Timeline: 分享到微信朋友圈 (此种消息已经限制不能分享到朋友圈)
	 * @param title
	 *            音乐消息的标题
	 * @param desc
	 *            音乐消息的概要信息
	 * @param musicUrl
	 *            音乐消息的目标URL
	 * @param musicDataUrl
	 *            音乐消息的数据URL
	 * @param imgData
	 *            原图文件数据
	 * @param imgDataLen
	 *            原图文件数据长度(图片大小不z能超过10M)
	 * @param messageExt
	 *            游戏分享是传入字符串，通过此分享消息拉起游戏会通过 OnWakeUpNotify(WakeupRet
	 *            ret)中ret.messageExt回传给游戏
	 * @param messageAction
	 *            scene为WechatScene_Timeline(分享到微信朋友圈)的情况下才起作用
	 *            WECHAT_SNS_JUMP_SHOWRANK 跳排行,查看排行榜 WECHAT_SNS_JUMP_URL
	 *            跳链接,查看详情 WECHAT_SNS_JUMP_APP 跳APP,玩一把
	 * @return void 通过游戏设置的全局回调的OnShareNotify(ShareRet& shareRet)回调返回数据给游戏,
	 *         shareRet.flag值表示返回状态, 可能值及说明如下: eFlag_Succ: 分享成功 eFlag_Error:
	 *         分享失败 shareRet.messageExt 为游戏分享到微信时候传入的自定义数据
	 */

	public void WGSendToWeixinWithMusic(eWechatScene scene, String title,
			String desc, String musicUrl, String musicDataUrl,
			String mediaTagName, byte[] imgData, int imgDataLen,
			String mediaExt, String mediaAction) {
		Logger.d("" + "WGSendToWeixinWithMusic scene: " + scene);
		int code = this.checkWXEnv();

		switch (code) {
		case CallbackFlag.eFlag_WX_NotInstall: {
			ShareRet sr = new ShareRet();
			sr.platform = WeGame.getInstance().getPlatId();
			sr.desc = "Weixin NOT Installed";
			sr.flag = CallbackFlag.eFlag_WX_NotInstall;
			WeGameNotifyGame.getInstance().OnShareNotify(sr);
			return;
		}
		case CallbackFlag.eFlag_WX_NotSupportApi: {
			ShareRet sr = new ShareRet();
			sr.platform = WeGame.getInstance().getPlatId();
			sr.desc = "Weixin API NOT Support";
			sr.flag = CallbackFlag.eFlag_WX_NotSupportApi;
			WeGameNotifyGame.getInstance().OnShareNotify(sr);
			return;
		}
		}

		if (imgData == null || imgDataLen == 0) {
			Logger.e("imgData should NOT BE NULL and imgDataLen !== 0");
			return;
		}

		Logger.d("imgData: " + imgData.length + ";imgDataLen: " + imgDataLen);
		if (imgData.length > IMG_MAX_SIZE) {
			Logger.w("imgData too big, it should be less than 10M");
		}

		Bitmap bmp = BitmapFactory.decodeByteArray(imgData, 0, imgDataLen);
		if(null == bmp){
			Logger.e("imgData decode to bmp error!");
			return;
		}
		float w = bmp.getWidth();
		float h = bmp.getHeight();

		Bitmap thumbBmp = null;
		if (w > h) {
			thumbBmp = Bitmap.createScaledBitmap(bmp, THUMB_SIZE,
					(int) (THUMB_SIZE * (h / w)), true);
		} else {
			thumbBmp = Bitmap.createScaledBitmap(bmp,
					(int) (THUMB_SIZE * (w / h)), THUMB_SIZE, true);
		}
		ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
		thumbBmp.compress(Bitmap.CompressFormat.JPEG, 90, byteStream);

		WXMusicObject wechatMusicObject = new WXMusicObject();
		wechatMusicObject.musicUrl = musicUrl;
		wechatMusicObject.musicDataUrl = musicDataUrl;

		WXMediaMessage msg = new WXMediaMessage();
		msg.title = title;
		msg.description = desc;
		msg.mediaObject = wechatMusicObject;
		msg.thumbData = byteStream.toByteArray();
		msg.mediaTagName = mediaTagName;
		msg.messageExt = mediaExt;
		msg.messageAction = mediaAction;
		Logger.d("imgData " + imgData.length);
		Logger.d("thumbData " + byteStream.toByteArray().length);

		SendMessageToWX.Req req = new SendMessageToWX.Req();
		LoginRet lr = new LoginRet();
		LoginUtils.getLocalLoginRet(lr);
		req.openId = lr.open_id;
		req.transaction = "img";
		req.message = msg;
		req.scene = scene.val();
		boolean isSendReqSucc = WeGame.getInstance().api.sendReq(req);
		Logger.d("WGSendToWeixinWithMusic isSendReqSucc: " + isSendReqSucc);
	}

	/**
	 * @param scene
	 *            eQQScene: QQScene_QZone : 分享到空间 QQScene_Session：分享到会话
	 * @param title
	 *            结构化消息的标题
	 * @param desc
	 *            结构化消息的概要信息
	 * @param musicUrl
	 *            点击消息后跳转的URL
	 * @param musicDataUrl
	 *            音乐数据URL（例如http:// ***.mp3）
	 * @param imgUrl
	 *            分享消息缩略图URL
	 * @return void 通过游戏设置的全局回调的OnShareNotify(ShareRet& shareRet)回调返回数据给游戏,
	 *         shareRet.flag值表示返回状态, 可能值及说明如下: eFlag_Succ: 分享成功 eFlag_Error:
	 *         分享失败
	 */

	public void WGSendToQQWithMusic(eQQScene scene, String title, String desc,
			String musicUrl, String musicDataUrl, String imgUrl) {
		Logger.d("WGSendToQQWithMusic ");
		int code = this.checkQQEnv();
		if (code != CallbackFlag.eFlag_Succ) {
			return;
		}
		if (mTencent == null) {
			Logger.d("WGSendToQQWithMusic" + "mTencent NULL");
			return; // mTencent为空了, 再往下走除了crash还能干什么?
		} else if (mTencent.getOpenId() == null) {
			Logger.d("WGSendToQQWithMusic" + "getOpenId NULL");
		} else if (!mTencent.isSessionValid()) {
			Logger.d("WGSendToQQWithMusic" + "isSessionValid FALSE");
		}

		Logger.d("mTencent.isSessionValid(): " + mTencent.isSessionValid());
		if (scene.val() != QQShare.SHARE_TO_QQ_FLAG_QZONE_AUTO_OPEN
				&& scene.val() != QQShare.SHARE_TO_QQ_FLAG_QZONE_ITEM_HIDE) {
			Logger.e("scene error, scene should be QQShare.SHARE_TO_QQ_FLAG_QZONE_AUTO_OPEN or QQShare.SHARE_TO_QQ_FLAG_QZONE_ITEM_HIDE");
			return;
		}
		if(null == musicUrl || musicUrl.trim().length() == 0) {
		    ShareRet ret = new ShareRet();
            ret.flag = CallbackFlag.eFlag_Error;
            ret.desc = "musicUrl cann't be empty!";
            ret.platform = WeGame.QQPLATID;
            WeGameNotifyGame.getInstance().OnShareNotify(ret);
            Logger.e("musicUrl cann't be empty");
            return;
		}
		
		if(scene.val() == QQShare.SHARE_TO_QQ_FLAG_QZONE_AUTO_OPEN && musicUrl.length() > 256) {
		    Logger.e("musicUrl is too long(>256), maybe fail to share.it's length:" + musicUrl.length()); 
		}
		
		if (null == imgUrl) {
			Logger.e("Music Image URL not null");
		}
		
		final VersionHelper vh = new VersionHelper(getActivity(),
				QQVersionApiManager.QQ_PKG_NAME);
		if (mTencent != null) {
			LoginRet lr = new LoginRet();
			LoginUtils.getLocalLoginRet(lr);
			Logger.d("sendReq to QQ With OpenId: " + mTencent.getOpenId()  +";and local openid:"+lr.open_id);
			Bundle params = new Bundle();
			params.putInt(QQShare.SHARE_TO_QQ_KEY_TYPE,
					QQShare.SHARE_TO_QQ_TYPE_AUDIO);
			params.putString(QQShare.SHARE_TO_QQ_TARGET_URL, musicUrl);
			params.putString(QQShare.SHARE_TO_QQ_TITLE, title);
			params.putString(QQShare.SHARE_TO_QQ_AUDIO_URL, musicDataUrl);
			params.putString(QQShare.SHARE_TO_QQ_IMAGE_URL, imgUrl);
			Logger.d("SHARE_TO_QQ_IMAGE_URL:"+imgUrl);
			params.putString(QQShare.SHARE_TO_QQ_SUMMARY, desc);
			params.putString(QQShare.SHARE_TO_QQ_APP_NAME, getAppName());
			params.putInt(QQShare.SHARE_TO_QQ_EXT_INT, scene.val());
			Logger.d("WGSendToQQWithMusic params:");
			Logger.d(params);
			mTencent.shareToQQ(mActivity, params, new IUiListener() {
				public void onCancel() {
					Logger.d("WGSendToQQWithMusic onCancel");
					if (vh.compareVersion("4.6") >= 0) { // 4.6一下版本
						ShareRet ret = new ShareRet();
						ret.flag = CallbackFlag.eFlag_QQ_UserCancel;
						ret.platform = WeGame.QQPLATID;
						ret.desc = "use cancel";
						WeGameNotifyGame.getInstance().OnShareNotify(ret);
					}
				}

				public void onComplete(Object arg0) {
					Logger.d("WGSendToQQWithMusic onComplete");
					if (vh.compareVersion("4.6") >= 0) { // 4.6一下版本
						ShareRet ret = new ShareRet();
						ret.flag = CallbackFlag.eFlag_Succ;
						ret.platform = WeGame.QQPLATID;
						ret.desc = "success";
						WeGameNotifyGame.getInstance().OnShareNotify(ret);
					}
				}

				public void onError(UiError arg0) {
					Logger.d("WGSendToQQWithMusic onError Code (" + arg0.errorCode
							+ "), Message(" + arg0.errorMessage + ")");
					if (vh.compareVersion("4.6") >= 0) { // 4.6一下版本
						ShareRet ret = new ShareRet();
						ret.flag = CallbackFlag.eFlag_Error;
						ret.desc = arg0.errorMessage == null ? ""
								: arg0.errorMessage;
						ret.platform = WeGame.QQPLATID;
						WeGameNotifyGame.getInstance().OnShareNotify(ret);
					}
				}
			});
		}

		if (vh.compareVersion("4.5") <= 0) { // 4.6一下版本
			ShareRet ret = new ShareRet();
			ret.flag = CallbackFlag.eFlag_Succ;
			ret.platform = WeGame.QQPLATID;
			WeGameNotifyGame.getInstance().OnShareNotify(ret);
		}
	}

	/**
	 * 
	 * @param scene
	 *            Tencent.SHARE_TO_QQ_FLAG_QZONE_AUTO_OPEN弹窗分享到Qzone,
	 *            Tencent.SHARE_TO_QQ_FLAG_QZONE_ITEM_HIDE 分享到个会话界面
	 * @param imgFilePath
	 *            本地文件路径
	 */
	public void WGSendToQQWithPhoto(int scene, String imgFilePath) {
		if (!checkApiSupport(ApiName.WGSendToQQWithPhoto)) {
			ShareRet ret = new ShareRet();
			ret.flag = CallbackFlag.eFlag_Error;
			ret.desc = "分享接口只支持手Q 4.5";
			ret.platform = WeGame.QQPLATID;
			WeGameNotifyGame.getInstance().OnShareNotify(ret);
			Logger.d("WGSendToQQWithPhoto only supported by MobileQQ 4.5 or later");
			return;
		}
		String gameName = getAppName();
		if (imgFilePath == null || imgFilePath.length() == 0) {
		    ShareRet ret = new ShareRet();
            ret.flag = CallbackFlag.eFlag_Error;
            ret.desc = "image file path emypty!";
            ret.platform = WeGame.QQPLATID;
            WeGameNotifyGame.getInstance().OnShareNotify(ret);
			Logger.w("image file path emypty");
			return;
		}

		if (gameName == null || gameName.length() == 0) {
			Logger.e("gameName emypty");
			return;
		}

		if (scene != QQShare.SHARE_TO_QQ_FLAG_QZONE_AUTO_OPEN
				&& scene != QQShare.SHARE_TO_QQ_FLAG_QZONE_ITEM_HIDE) {
			Logger.e("scene error, scene should be Tencent.SHARE_TO_QQ_FLAG_QZONE_AUTO_OPEN or Tencent.SHARE_TO_QQ_FLAG_QZONE_ITEM_HIDE");
			return;
		}

		File file = new File(imgFilePath);  
        if(!file.exists()) { 
		    ShareRet ret = new ShareRet();
            ret.flag = CallbackFlag.eFlag_Error;
            ret.desc = "image file path invalid or not exists!";
            ret.platform = WeGame.QQPLATID;
            WeGameNotifyGame.getInstance().OnShareNotify(ret);
            Logger.w("image file path invalid or not exists!");
            return ;
		}
        final VersionHelper vh = new VersionHelper(getActivity(),
				QQVersionApiManager.QQ_PKG_NAME);
		if (mTencent != null) {
			LoginRet lr = new LoginRet();
			LoginUtils.getLocalLoginRet(lr);
			Logger.d("sendReq to QQ With OpenId: " + mTencent.getOpenId()  +";and local openid:"+lr.open_id);
			Bundle params = new Bundle();
			params.putInt(QQShare.SHARE_TO_QQ_KEY_TYPE,
					QQShare.SHARE_TO_QQ_TYPE_IMAGE);
			params.putInt(QQShare.SHARE_TO_QQ_EXT_INT, scene); // 标识是否需要自动弹出分享到空间的框
			params.putString(QQShare.SHARE_TO_QQ_IMAGE_LOCAL_URL, imgFilePath);
			params.putString(QQShare.SHARE_TO_QQ_APP_NAME, gameName);
			mTencent.shareToQQ(mActivity, params, new IUiListener() {
				public void onCancel() {
					Logger.d("WGSendToQQWithPhoto onCancel");
					if (vh.compareVersion("4.6") >= 0) { // 4.6一下版本
						ShareRet ret = new ShareRet();
						ret.flag = CallbackFlag.eFlag_QQ_UserCancel;
						ret.platform = WeGame.QQPLATID;
						ret.desc = "use cancel";
						WeGameNotifyGame.getInstance().OnShareNotify(ret);
					}
				}

				public void onComplete(Object arg0) {
					Logger.d("WGSendToQQWithPhoto onComplete");
					if (vh.compareVersion("4.6") >= 0) { // 4.6一下版本
						ShareRet ret = new ShareRet();
						ret.flag = CallbackFlag.eFlag_Succ;
						ret.platform = WeGame.QQPLATID;
						ret.desc = "success";
						WeGameNotifyGame.getInstance().OnShareNotify(ret);
					}
				}

				public void onError(UiError arg0) {
					Logger.d("WGSendToQQWithPhoto onError Code (" + arg0.errorCode
							+ "), Message(" + arg0.errorMessage + ")");
					if (vh.compareVersion("4.6") >= 0) { // 4.6一下版本
						ShareRet ret = new ShareRet();
						ret.flag = CallbackFlag.eFlag_Error;
						ret.desc = arg0.errorMessage == null ? ""
								: arg0.errorMessage;
						ret.platform = WeGame.QQPLATID;
						WeGameNotifyGame.getInstance().OnShareNotify(ret);
					}
				}
			});
		}

		if (vh.compareVersion("4.5") <= 0) { // 4.6一下版本
			ShareRet ret = new ShareRet();
			ret.flag = CallbackFlag.eFlag_Succ;
			ret.platform = WeGame.QQPLATID;
			WeGameNotifyGame.getInstance().OnShareNotify(ret);
		}
	}

	public void WGSendToQQ(int scene, String title, String desc, String url,
            String imgUrl, int imgUrlLen) {
	    sendToQQ(scene, title, desc, url, imgUrl, imgUrlLen, true);
	}
	
	public void sendToQQ(int scene, String title, String desc, String url,
			String imgUrl, int imgUrlLen, final boolean useNotify) {
		Logger.d("WGSendToQQ ");
		int code = this.checkQQEnv();
		if (code != CallbackFlag.eFlag_Succ) {
			return;
		}

		if (mTencent == null) {
			Logger.d("WGSendToQQ" + "mTencent NULL");
			return; // mTencent为空了, 再往下走除了crash还能干什么?
		} else if (mTencent.getOpenId() == null) {
			Logger.d("WGSendToQQ" + "getOpenId NULL");
		} else if (!mTencent.isSessionValid()) {
			Logger.d("WGSendToQQ" + "isSessionValid FALSE");
		}

		Logger.d("mTencent.isSessionValid(): " + mTencent.isSessionValid());
		if (scene != QQShare.SHARE_TO_QQ_FLAG_QZONE_AUTO_OPEN
				&& scene != QQShare.SHARE_TO_QQ_FLAG_QZONE_ITEM_HIDE) {
			Logger.e("scene error, scene should be QQShare.SHARE_TO_QQ_FLAG_QZONE_AUTO_OPEN or QQShare.SHARE_TO_QQ_FLAG_QZONE_ITEM_HIDE");
			return;
		}

		if(scene == QQShare.SHARE_TO_QQ_FLAG_QZONE_AUTO_OPEN && url != null && url.length() > 256){
		    Logger.w("url is too long(>256), maybe fail to share. it's value:" + url.length());
		}
		
		final VersionHelper vh = new VersionHelper(getActivity(),
				QQVersionApiManager.QQ_PKG_NAME);
		if (mTencent != null) {
			LoginRet lr = new LoginRet();
			LoginUtils.getLocalLoginRet(lr);
			Logger.d("sendReq to QQ With OpenId: " + mTencent.getOpenId()  +";and local openid:"+lr.open_id);
			Bundle params = new Bundle();
			params.putString(QQShare.SHARE_TO_QQ_TITLE, title);
			params.putString(QQShare.SHARE_TO_QQ_SUMMARY, desc);
			params.putString(QQShare.SHARE_TO_QQ_TARGET_URL, url);
			params.putString(QQShare.SHARE_TO_QQ_IMAGE_URL, imgUrl);
			Logger.d("SHARE_TO_QQ_IMAGE_URL:"+imgUrl);
			params.putInt(QQShare.SHARE_TO_QQ_EXT_INT, scene); // 标识是否需要自动弹出分享到空间的框
			params.putString(QQShare.SHARE_TO_QQ_APP_NAME, getAppName());
			Logger.d(params);

			mTencent.shareToQQ(mActivity, params, new IUiListener() {
				public void onCancel() {
					Logger.d("WGSendToQQ onCancel");
					if (vh.compareVersion("4.6") >= 0) { // 4.6一下版本
						ShareRet ret = new ShareRet();
						ret.flag = CallbackFlag.eFlag_QQ_UserCancel;
						ret.platform = WeGame.QQPLATID;
						ret.desc = "use cancel";
						if(useNotify) {
						    WeGameNotifyGame.getInstance().OnShareNotify(ret);
						} else {
						    Logger.d("sendtoQQ notify, flag:" + ret.flag + ",platform:" + ret.platform); 
						}
					}
				}

				public void onComplete(Object arg0) {
					Logger.d("WGSendToQQ onComplete");
					if (vh.compareVersion("4.6") >= 0) { // 4.6一下版本
						ShareRet ret = new ShareRet();
						ret.flag = CallbackFlag.eFlag_Succ;
						ret.platform = WeGame.QQPLATID;
						ret.desc = "success";
						if(useNotify) {
                            WeGameNotifyGame.getInstance().OnShareNotify(ret);
                        } else {
                            Logger.d("sendtoQQ notify, flag:" + ret.flag + ",platform:" + ret.platform); 
                        }
					} 
				}

				public void onError(UiError arg0) {
					Logger.d("WGSendToQQ onError Code (" + arg0.errorCode
							+ "), Message(" + arg0.errorMessage + ")");
					if (vh.compareVersion("4.6") >= 0) { // 4.6一下版本
						ShareRet ret = new ShareRet();
						ret.flag = CallbackFlag.eFlag_Error;
						ret.desc = arg0.errorMessage == null ? ""
								: arg0.errorMessage;
						ret.platform = WeGame.QQPLATID;
						if(useNotify) {
                            WeGameNotifyGame.getInstance().OnShareNotify(ret);
                        } else {
                            Logger.d("sendtoQQ notify, flag:" + ret.flag + ",platform:" + ret.platform); 
                        }
					}
				}
			});
		}

		if (vh.compareVersion("4.5") <= 0) { // 4.6一下版本
			ShareRet ret = new ShareRet();
			ret.flag = CallbackFlag.eFlag_Succ;
			ret.platform = WeGame.QQPLATID;
			if(useNotify) {
                WeGameNotifyGame.getInstance().OnShareNotify(ret);
            } else {
                Logger.d("sendtoQQ notify, flag:" + ret.flag + ",platform:" + ret.platform); 
            }
		}
	}

	public boolean feedback(String game, String txt) {
		if (game == null) {
			game = "";
		}
		if (txt == null) {
			txt = "";
		}

		LoginRet lr = new LoginRet();
		LoginUtils.getLocalLoginRet(lr);
		MsdkThreadManager.getInstance().sendFeedback(game, txt, lr.platform,
				lr.open_id);
		return true;
	}

	// kevin只需要这个版本号就行
    public String getMSDKVersion(){
        return MSDK_VERSION;
    }
    
	public String WGGetVersion() {
		String VERSION_KEY = "VERSION";
		String VERSION_FILE = "msdkinfo.ini";
		Activity ctx = WeGame.getInstance().getActivity();

		try {
			InputStream inputStream = ctx.getResources().getAssets()
					.open(VERSION_FILE);
			Properties properties = new Properties();
			properties.load(inputStream);
			String msdkVersion = properties.getProperty(VERSION_KEY, "");
			if (!MSDK_VERSION.equals(msdkVersion)) { // 如果代码里面的版本号和assets里面的不一样, 提示
				Logger.d("MSDK_VERSION in code is different from VERSION in assets/msdkmetadata.ini");
			}
			if (msdkVersion.contains("$")) {
			    // if contains $, maybe it is a version built by local ant
			    return MSDK_VERSION;
			}
			return msdkVersion;
		} catch (Exception e) {
			// e.printStackTrace();
			Logger.d("MSDK Version does not match, is this a development version?");
			return MSDK_VERSION;
		}
	}

	public void enableCrashReport(boolean bRdmEnable, boolean bMtaEnable) {
		mStat.enableCrashReport(bRdmEnable, bMtaEnable);
	}

	public void WGReportEvent(String name, String body, boolean isRealTime) {
		Logger.d("called");
		mStat.reportEvent(name, body, this.mPlatId, isRealTime);
	}

	public void WGReportEvent(String name, HashMap<String, String> params,
			boolean isRealTime) {
		if (null == name || null == params) {
			name = "";
			params = new HashMap<String, String>();
			Logger.e("WGReportEvent Error: name=" + name + "params="
					+ params.toString());
			return;
		}
		mStat.reportEvent(name, params, this.mPlatId, isRealTime);
	}

	public void testSpeed(ArrayList<String> addrList) {
		mStat.speedTest(addrList);
	}

	public String getLocalTokenByType(int type) {
		LoginRet lr = new LoginRet();
		LoginUtils.getLocalLoginRet(lr);

		for (TokenRet tr : lr.token) {
			if (tr.type == type) {
				return tr.value;
			}
		}

		return null;
	}

	public String getApiDomain() {
		Logger.d("Use DOMAIN: " + ConfigManager.getApiDomain(mActivity));
		String originDomain = ConfigManager.getApiDomain(mActivity).trim();
		return originDomain;
	}

	public void onActivityResult(int requestCode, int resultCode, Intent data) {
		Logger.d("WeGame onActivityResult");
		new QQLogin().onActivityResult(requestCode, resultCode, data);
	}

	static public String setDescribe(int flag, int platform) {
		String desc = "";
		if (flag == CallbackFlag.eFlag_Succ) {
			if (platform == WeGame.QQPLATID || platform == WeGame.QQHALL) {
				desc = ":-) , QQ授权成功";
			} else {
				desc = ":-) , WX授权成功";
			}
		} else if (flag == CallbackFlag.eFlag_WX_RefreshTokenSucc) {
			desc = ":-) , 微信refresh换acctoken 成功";
		} else if (flag == CallbackFlag.eFlag_WX_RefreshTokenFail) {
			desc = ":-( , 微信refresh换acctoken 失败";
		}
		return desc;
	}

	public String getAppName() {
		String appName = "";
		try {
			PackageInfo pkgInfo = mActivity.getPackageManager().getPackageInfo(
					mActivity.getPackageName(), 0);
			appName = pkgInfo.applicationInfo.loadLabel(
					mActivity.getPackageManager()).toString();
		} catch (NameNotFoundException e) {
			e.printStackTrace();
		}
		return appName;
	}

	public boolean checkApiSupport(ApiName api) {
		if (api.val() < ApiName.MAX_QQ_API) {
			return QQVersionApiManager.isSupport(this.mActivity, api);
		} else if (api.val() < ApiName.MAX_WX_API) {
			return true;
		} else {
			return true;
		}
	}

	public void logPlatformSDKVersion() {
		Logger.d("OpenSDK: " + com.tencent.connect.common.Constants.SDK_VERSION);
		Logger.d("WeixinSDKVersionName: "
				+ com.tencent.mm.sdk.constants.Build.SDK_VERSION_NAME);
		Logger.d("WeixinSDKVersionCode: "
				+ com.tencent.mm.sdk.constants.Build.SDK_INT);
		Logger.d("Mta: " + StatConstants.VERSION);
		Logger.d("Beacon: " + UserAction.getSDKVersion());
		Logger.d("WeixinClient: "
				+ VersionHelper.getAppVersionName(mActivity, "com.tencent.mm"));
		Logger.d("QQClient: "
				+ VersionHelper.getAppVersionName(mActivity,
						"com.tencent.mobileqq"));
		Logger.d("QQGameClient: "
				+ VersionHelper.getAppVersionName(mActivity,
						"com.tencent.qqgame"));
    }

	public void feedback(String body) {
		if (body == null) {
			body = "";
		}

		LoginRet lr = new LoginRet();
		LoginUtils.getLocalLoginRet(lr);
		MsdkThreadManager.getInstance().sendFeedbackWithAppid(body);
	}

	/**
	 * 通过游戏加群
	 */
	public void WGJoinQQGroup(String qqGroupKey) {
		if (mTencent == null) {
			Logger.w("WGJoinQQGroup" + "mTencent NULL");
			return;
		} 
		final VersionHelper vh = new VersionHelper(getActivity(),
				QQVersionApiManager.QQ_PKG_NAME);
		if (vh.compareVersion("4.7") < 0) { 
			Logger.w("WGJoinQQGroup need QQ version large than 4.7");
		}
		if(T.ckIsEmpty(qqGroupKey)){
			Logger.w("WGJoinQQGroup:qqGroupId:"+qqGroupKey);
		}
		mTencent.joinQQGroup(this.mActivity, qqGroupKey);
		Logger.d("WGJoinQQGroup called");
	}
	
	/**
	 * 通过游戏绑定群
	 */
	public void WGBindQQGroup(
			String unionid, 
			String union_name, 
			String zoneid, 
			String signature) {
		if (mTencent == null) {
			Logger.w("WGBindQQGroup" + "mTencent NULL");
			return;
		} 
		final VersionHelper vh = new VersionHelper(getActivity(),
				QQVersionApiManager.QQ_PKG_NAME);
		if (vh.compareVersion("5.1") < 0) { 
			Logger.w("WGBindQQGroup need QQ version large than 5.1");
		}
		if(T.ckNonEmpty(unionid,union_name,zoneid,signature)){
			Logger.w("WGBindQQGroup :unionid:"+unionid+";union_name:"+union_name+";zoneid"+zoneid+";signature:"+signature);
		}
		Bundle params = new Bundle();
        params.putString(GameAppOperation.GAME_UNION_ID,unionid);
        params.putString(GameAppOperation.GAME_UNION_NAME, union_name);
        params.putString(GameAppOperation.GAME_ZONE_ID, zoneid);
        params.putString(GameAppOperation.GAME_SIGNATURE, signature);
		mTencent.bindQQGroup(this.mActivity, params);
		//目前提供给游戏的回调都是成功，等openSDK支持以后再增加回调
		GroupRet groupRet = new GroupRet();
        groupRet.flag = flag;
        groupRet.errorCode = ErrorCodeFlag.SDK_SUCCESS;
        groupRet.desc = "call WGBindQQGroup finished ，but not sure succ or failed";
        groupRet.platform = WeGame.QQPLATID;
		WeGameNotifyGame.getInstance().NotifyGameBindQQGroup(groupRet);
		Logger.d("WGBindQQGroup called");
	}
	/**
	 * 通过游戏加QQ好友
	 */
	public void WGAddGameFriendToQQ(String fopenid, String desc, String message) {
		if (mTencent == null) {
			Logger.w("WGAddGameFriendToQQ" + "mTencent NULL");
			return;
		} 
		final VersionHelper vh = new VersionHelper(getActivity(),
				QQVersionApiManager.QQ_PKG_NAME);
		if (vh.compareVersion("5.1") < 0) { 
			Logger.w("WGAddGameFriendToQQ need QQ version large than 5.1");
		}
		if(T.ckNonEmpty(fopenid,desc,message)){
			Logger.w("WGAddGameFriendToQQ :fopenid:"+fopenid+";desc:"+desc+";message"+message);
		}
		Bundle params = new Bundle();
        params.putString(GameAppOperation.GAME_FRIEND_OPENID,fopenid);
        params.putString(GameAppOperation.GAME_FRIEND_LABEL, desc);
        params.putString(GameAppOperation.GAME_FRIEND_ADD_MESSAGE, message);
        mTencent.makeFriend(this.mActivity, params);
        Logger.d("WGAddGameFriendToQQ called");
	}
	
	/**
	 * 微信卡券
	 * @param cardId
	 * @param timestamp
	 * @param sign
	 */
	public void WGAddCardToWXCardPackage(String cardId, String timestamp, String sign){
		int code = this.checkWXEnv();
		Logger.d("WGAddCardToWXCardPackage code:"+ code);
		switch (code) {
		    case CallbackFlag.eFlag_WX_NotInstall: {
		        CardRet ret = new CardRet();
		        ret.platform = WeGame.getInstance().getPlatId();
		        ret.desc = "Weixin NOT Installed";
		        ret.flag = CallbackFlag.eFlag_WX_NotInstall;
		        WeGameNotifyGame.getInstance().OnAddWXCardNotify(ret);
		        return;
		    }
		    case CallbackFlag.eFlag_WX_NotSupportApi: {
		    	CardRet ret = new CardRet();
		    	ret.platform = WeGame.getInstance().getPlatId();
		    	ret.desc = "Weixin API NOT Support";
		    	ret.flag = CallbackFlag.eFlag_WX_NotSupportApi;
		        WeGameNotifyGame.getInstance().OnAddWXCardNotify(ret);
		        return;
		    }
		}
		
    	String cardExtMsg = "{\"code\":\"\",\"openid\":\"\",\"timestamp\":\""+timestamp + "\",\"signature\":\""+ sign +"\"}";
     	List<AddCardToWXCardPackage.WXCardItem> cardItems = new ArrayList<AddCardToWXCardPackage.WXCardItem>();
		AddCardToWXCardPackage.WXCardItem cardItem = new AddCardToWXCardPackage.WXCardItem();
		cardItem.cardId = cardId;
		cardItem.cardExtMsg = cardExtMsg;
		cardItems.add(cardItem);
		
		AddCardToWXCardPackage.Req req = new AddCardToWXCardPackage.Req();
		req.cardArrary = cardItems;
		req.transaction = "wechatAddCardToWXCardPackage";
		boolean ret = api.sendReq(req);
		Logger.d("sendMsg ret:" + ret);
    }
	
	// 主要用于AD广告事件的上报，因为默认的内置浏览器泄漏，因此把内置浏览器作为一个单独的进程，但上报进程又需要在游戏进程中调用
	private BroadcastReceiver mADReportReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            if("com.tencent.msdk.webview.adreport".equals(intent.getAction())) {
                String adidstr = intent.getStringExtra("adids");
                if(adidstr == null) {
                    return;
                }
                String[] adArray = adidstr.split(",");
                if(adArray != null) {
                    for(int i=0; i < adArray.length; i++) {
                        ReportEvent.ReportADEvent(eEVENT_TYPE.eEVENT_AD_SHOW, adArray[i], ADPosInfo.POS_WEBVIEW_ID, 0);
                    }
                }
            }
        }
    };
    
	private void registerADReportReceiver(){
	    if(mActivity != null) {
            IntentFilter filter = new IntentFilter();
            filter.addAction("com.tencent.msdk.webview.adreport");
            mActivity.getApplicationContext().registerReceiver(mADReportReceiver, filter);
	    }
	}

	private void unRegisterADReportReceiver(){
	    try{
            if (mActivity != null) {
                mActivity.getApplicationContext().unregisterReceiver(mADReportReceiver);
            }
	    }catch(Exception e) {
	        e.printStackTrace();
	    }
	}
	// 相关调用结束
	
	// 上报事件
	public void ReportGameTime(int eventType){
	    mStat.reportGameTimeEvent(eventType);
	}
	
	public void OpenWXDeeplink(String deeplink) {
        if(deeplink.startsWith("weixin://")) {
    		Intent intent = new Intent(Intent.ACTION_VIEW);
    		intent.setData(Uri.parse(deeplink));
    		//intent.setClassName("com.tencent.mm", "com.tencent.mm.plugin.base.stub.WXCustomSchemeEntryActivity");
    		try {
    		    mActivity.startActivity(intent);
    		} catch (Exception e) {
    			e.printStackTrace();
    		}
        } else {
        	MsdkThreadManager.getInstance().openUrl(deeplink);
        }

	}
}
